\documentclass{bioinfo}

\usepackage{relsize} % for Cpp
\usepackage{xspace} % for Cpp
\usepackage{subfigure}

\usepackage{natbib}

\newcommand{\odgi}{ODGI}
\newcommand{\FIXME}{\textbf{!!FIXME!!}}
\newcommand{\cmd}[1]{{\scriptsize\textrm{#1}}}
\newcommand{\cmdbf}[1]{{\textbf{#1}}}
\newcommand{\topic}[1]{{\cmdbf{#1}}:}
\newcommand{\Rplus}{\protect\hspace{-.1em}\protect\raisebox{.35ex}{\smaller{\smaller\textbf{+}}}}
\newcommand{\pp}{\Rplus\Rplus}
\newcommand{\Cpp}{\mbox{C\Rplus\Rplus}\xspace}


\copyrightyear{2021} \pubyear{2021}

\access{Advance Access Publication Date: Day Month Year}
\appnotes{Application Note}

\begin{document}
    \firstpage{1}

    \subtitle{Pangenome analysis}

    \title[ODGI: scalable tools for pangenome graphs]{ODGI: scalable tools for pangenome graphs}
    \author[Guarracino, Heumos \textit{et~al}.]{
        Andrea Guarracino\,$^{\text{\sfb 1,}\dagger,*}$,
        Simon Heumos\,$^{\text{\sfb 2,}\dagger}$,
    % XXXXX,
        Pjotr~Prins\,$^{\text{\sfb 3}}$ and
        Erik~Garrison\,$^{\text{\sfb 3,}*}$
    }
    \address{$^{\text{\sf 1}}$Biology, University of Tor Vergata, Rome, 00133, Italy \\
        $^{\text{\sf 2}}$QBiC, University of Tübingen, Tübingen, XXXXXXXXXX, Germany \\
        $^{\text{\sf 3}}$Genetics Genomics \& Informatics, UTHSC, Memphis, TN, USA
    }

    \corresp{$^\ast$To whom correspondence should be addressed.}
    \corresp{$^\dagger$The authors wish it to be known that the first two authors should be regarded as joint First Authors.}

    \history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

    \editor{Associate Editor: XXXXXXX}

    \abstract{ \textbf{Motivation:} Pangenomes address the
      shortcomings of mainline genomics workflows, in particular with
      regard to reference genome bias and the identifation of complex
      structural variants.
        %
        \\ \textbf{Results:} Here we present \odgi\, a novel range of
        scalable tools that makes use of an efficient in-memory
        representation of DNA graphs. \odgi\ can handle hundreds of
        large genomes at the same time while maintaining fast
        execution runtime and low memory overheads.  \odgi\ includes
        tools for detecting complex regions, extracting \textit{loci},
        exploratory analysis, sorting, removing artifacts, and graphs
        manipulation and visualisation.
        %
        \\
        \textbf{Availability:} \odgi\ is software written in the \Cpp\ programming language and
        published under the permissive MIT license. Source code and user manual can be downloaded from
        \href{https://github.com/pangenome/odgi}{https://github.com/pangenome/odgi}.\\
        %
        \textbf{Contact:}
        % \href{andreaguarracino@outlook.com}{andreaguarracino@outlook.com},
        egarris5@uthcs.edu\\
        \textbf{Supplementary information:} Supplementary data are available at \textit{Bioinformatics} online.}

    \maketitle

    \input{figure_p}

    \section{Introduction}

    A pangenome models the full set of genomic elements in a population~\citep{32453966}. Indeed, these data structures
    encode the mutual relationships between all the genomes represented, in contrast to reference-based approaches
    which relate sequences only to a particular genome, chosen as reference. A class of methods to represent
    pangenomes involves the \textit{sequence graphs}~\citep{2488477}, where similar orthologous regions between genomes
    collapse into a single representative sequence. In \textit{node-labeled} sequence graphs, nodes indicate DNA
    sequences, with edges connecting the nodes that are concatenated in the sequences represented in the graph. A
    \textit{bidirected} sequence graph represents both strands of DNA. On this model, \textit{variation graphs} add the
    concept of \textit{path} to embed linear sequences (e.g., genomes or haplotypes) into the graph~\citep{30125266}.
    Paths provide a stable coordinate system, allowing graph annotations and interoperability between different graphs.

    Thanks to advances in sequencing technologies, new genome assemblies are produced at a high rate. This amount of
    data offers the opportunity to study genomic variation as never before, but it also brings challenges in how to
    represent and manipulate hundreds of genomes at a gigabase scale. Variation graphs compactly represent the full
    genetic variation across a population, but graph-based data structures present computational overheads: in addition
    to the sequences, they must also represent the graph topology. Several genome data structures were developed to
    address these challenges~\citep{33040146}. Memory-efficient representations do not allow dynamic updates to the
    graph. Furthermore, the changes must perform efficiently on the complex graphs generated from whole-genome
    alignment of vertebrates. Highly repetitive regions, such as centromeres, segmental duplications, and acrocentric
    chromosomes lead to graphs which present very high-depth nodes. The node depth is defined as the
    number of times in which the node is crossed by all the paths embedded in the graph. High depth increases the
    complexity of the operations performed on the paths and the nodes they cross.

    To overcome this limitation, we have developed an Optimized Dynamic Genome/Graph Implementation (ODGI). Each tool
    loads graphs into the succinct dynamic HandleGraph model~\citep{33040146} and applies methods based on the
    HandleGraph API. Several algorithms are shared with the VG toolkit (VG)~\citep{30125266}, the state-of-the-art
    toolkit for working with pangenome graphs. However, although similar in scope to VG, \odgi\ importantly differs in
    its design to support highly complex pangenome graphs. The majority of the \odgi\ tools are implemented in an
    index-free manner, avoiding the burning task to create an index structure. Indeed, index-constrained
    implementations require building indexes also for single or little operations on the graphs. Moreover,
    thanks to its efficient path representation, \odgi\ tools can build the internal graph representation (the \odgi\
    format) in parallel, which is one of the major bottlenecks when working with very large and deep graphs,
    scaling up to hundreds of large vertebrate genomes.


    \odgi\ is entirely focused on "first-order" operations on the graph
    (Table~\ref{tab:01}), providing, unlike VG, no method to construct
    graphs from raw sequences, map reads, or call variants. It
    supports interrogation of the graph for basic dimensional
    properties, positional and path-related queries, and visualisation
    in one-dimension (1D) and two-dimensions (2D). \odgi\ also supports
    operations on the graph such as subset, subdivide, break, combine,
    normalize, or order its components, nodes, and paths. Most of the
    tools are designed to be applied together, piping the output of
    one tool into the next, thereby preventing the creation of
    intermediate files, and reducing the number of IO operations.

    \section{Methods}

    \odgi\ is designed to build and modify paths in parallel, keeping its representation in memory efficient. It
    applies concepts first introduced in the dynamic version of the Graph BWT~\citep{31406990}, a scalable
    implementation of the graph extension of the positional Burrows-Wheeler transform~\citep{28702075}. Specifically,
    we build a \textit{node-local} model of the graph, where the graph is stored in a vector of node structures.
    The identifier of each node is its offset in this vector plus 1. Each structure contains the sequence of the
    node, its edges in both directions (forward and backward), and a vector of \textit{path steps} that describes
    how the embedded paths walk across the node. Each step records the path identifier and the previous and next
    path steps on the same path. To reduce the encoding, we encode path steps using a local alphabet that maps the
    \textit{N} neighbors of the node into the range \textit{1..N}. To further save space, \textit{node deltas},
    rather than IDs, are stored in this alphabet. The delta between two nodes is defined as their distance in the
    graph vector (i.e., the difference between the node offsets). The path step vector, of length \textit{n}, is
    stored using a dynamic succinct integer vector that requires \textit{O(5nw)} bits, where \textit{w} is
    \textit{\textasciitilde log\textsubscript{2}(N)}. Finally, to allow operating on path steps in parallel, each node
    structure includes a byte-width mutex lock.


    Table~\ref{tab:02} shows a comparison of the operations necessary to extract a subgraph using \odgi\ and VG.

    %TODO to repeat on a bigger machine to avoid vg crashing
    \begin{table}[!t]
      \processtable{Example of performance improvement between
        \cmd{odgi} and \cmd{VG} equivalent commands with output file
        sizes. The centromere region was extracted from CHR 6 of the
        HPRC year one assembly\citep{HPRC}, i.e., 88 haploid, phased
        human genome assemblies from 44 individuals plus the chm13
        cell line and GRCh38 reference genomes stored in 4.3GB GFA
        format\citep{GFA}.
        %
        First GFS was converted from GFA to \odgi\ and \cmd{vg}
        formats, respectively.  \odgi's path implementation can
        process paths in parallel, outperforming \cmd{vg}. For the
        same reason \cmd{odgi extract} is $20\times$ faster than
        \cmd{vg chunk} extracting a portion from the full
        graph. \FIXME: vg never finished.
        %
        All timings were performed on a server class machine
        on SSD MODEL with X GB of RAM and 48 CPU cores (Y x 12 core
        AMD Opteron) Processor MODEL @ 3.3 GHz with 8MB L2
        Cache.\FIXME
          \label{tab:02}} {
          \resizebox{.99\columnwidth}{!}{
            \begin{tabular}{@{}lllll@{}}
                \toprule Operation & Tool & Runtime (mm:ss) & Memory (GB) & Output size (GB)    \\
                \midrule
                Format conversion                           &       &       &                   \\
                                    & \cmd{odgi build}      & 1:35  & 10.39 & 5.4               \\
                                    & \cmd{vg convert}      & 8:14  & 28.43 & 6.1               \\
                Subgraph extraction                         &       &       &                   \\
                                    & \cmd{odgi extract}    & 1:15  & 9.43  & 2.7               \\
                                    & \cmd{vg chunk}        & 21:09 & 59.33 & 1.7               \\
                \botrule
            \end{tabular}}}

    \end{table}


    \section{Features}

    \odgi\ has a wide range of commands.

    \topic{odgi build, view \& validate} pangenome graphs can be
    stored in the textual Graphical Fragment Assembly
    (GFAv1) format\citep{GFA}; \cmd{odgi build} and \cmd{odgi view}
    convert graphs from GFA to the \odgi\ format and \textit{vice versa}.
    \cmd{odgi validate} ascertains the graph data is correct, such as
    validating that paths respect the graph's topology.

    \topic{odgi viz, sort, draw \& layout} pangenome visualisation
    provides convenient insight into genomic variation. \cmd{odgi viz}
    generates a linearized representation of the pangenome and is
    capable of handling full length human chromosomes
    (Fig.~\ref{fig:1}a). \cmd{odgi sort} reorganises node order and
    simplifies the graph by applying several algorithms, including the
    novel `Path-Guided Stochastic Gradient Descent' algorithm.
    \cmd{odgi layout} generates a file with the X-Y coordinates for
    all nodes and \cmd{odgi draw} draws a layout of the graph
    (Fig.~\ref{fig:1}b).

    \topic{odgi stats, bin, depth \& degree} pangenome numerical
    counts provide insight into genome complexity in other
    ways. E.g., \cmd{odgi stats} returns the number of nodes,
    edges, paths, and graph length. \cmd{odgi bin} summarises path
    information into bins of a specified size, thereby enabling a
    summarised view of large genomes. \cmd{odgi depth} and
    \cmd{odgi degree} return the node depth and degree as defined by
    user provided criteria. These methods allow detection of complex
    genomic regions.

    \topic{odgi break, groom, chop \& unchop} pangenome graphs can be
    reorganised.  \cmd{odgi break} removes circular structures in the
    graph, thereby reducing complexity. \cmd{odgi groom} removes
    spurious inverted links by aligning the graph from the orientation
    that is supported by most paths. \cmd{odgi chop} divides long
    nodes into shorter ones at a maximum requested size, thereby
    simplifying downstream analysis.  \cmd{odgi unchop} joins nodes
    and embedded sequences that do not change the graph topology,
    thereby obtaining a more compact representation of the graph.

    \topic{odgi explode, squeeze \& extract} pangenome are constructed
    as a large graph. \cmd{odgi explode} separates units, such as
    chromosomes, into different files.  \cmd{odgi squeeze} merges
    multiple graphs into the same file whilst preventing node ID
    collisions. \cmd{odgi extract} extracts regions of the graph as
    defined by certain criteria, allowing downstream processing of
    smaller subgraphs.

    \topic{odgi position} pangenome graphs are flexible when it comes
    to coordinate systems. \cmd{odgi position} can use the coordinate
    system from a contained reference genome --- a dynamic liftover
    --- to display coordiates and other localised features, as is shown in
    Fig.~\ref{fig:1b}.




    \section{Discussion}
    We implemented a tool suite, \odgi\, which is simple to work with to analyse and manipulate pangenome graphs at a
    population scale. ODGI's path implementation allows working with graphs of any complexity, without particular
    limitations. We have demonstrated that \odgi\ tools efficiently perform with pangenome graphs embedding full human
    chromosomes. \odgi\ is not only a tool suite but also a library, already used in pangenome graphs building
    (\citep{pggb}) and normalization (\citep{smoothxg}). Furthermore, users can add new tools, exploiting ODGI as a
    framework where to implement algorithms working on variation graphs. Therefore, \odgi\ offers an efficient and
    extendable suite of tools ready for the upcoming challenges in the analyses of hundreds of genomes at a gigabase
    scale that characterize the pangenomic era.

%\begin{figure}[!tpb]%figure2
%%\centerline{\includegraphics{fig02.eps}}
%\caption{Caption, caption.}\label{fig:02}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     please remove the " % " symbol from \centerline{\includegraphics{fig01.eps}}
%     as it may ignore the figures.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \vspace*{+12pt}
    % \textit{Financial Support}: none declared.

    \textit{Conflict of Interest}: none declared.
    \vspace*{+12pt}

    % \section*{Data availability}

    % Data used to build Human pangenome graphs is available at \href{https://github.com/human-pangenomics/HPP_Year1_Data_Freeze_v1.0}{https://github.com/human-pangenomics/HPP\_Year1\_Data\_Freeze\_v1.0}.

    % \section*{Acknowledgements}
    %ToDo
    % XXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX.


    % \section*{Funding}
    %ToDo
    % This work has been supported by the XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX.

%    \vspace*{-12pt}

\bibliographystyle{natbib}
%\bibliographystyle{achemnat}
%\bibliographystyle{plainnat}
%\bibliographystyle{abbrv}
%\bibliographystyle{bioinformatics}
%
%\bibliographystyle{plain}
%
%\bibliography{Document}

\bibliography{bibliography}

\end{document}
