\PassOptionsToPackage{utf8}{inputenc}
\documentclass{bioinfo}

\usepackage[draft]{hyperref}
\usepackage{makecell}
\usepackage{comment}

\newcommand{\vocab}{\textbf}

\copyrightyear{XXXX} \pubyear{XXXX}

\access{Advance Access Publication Date: Day Month Year}
\appnotes{Genome Analysis}

\begin{document}
\firstpage{1}

\subtitle{Genome Analysis}

\title[short Title]{ODGI: understanding pangenome graphs}
\author[Heumos, \textit{et~al}.]{
Andrea Guarracino\,$^{\text{\sfb 1} \dagger}$,
Simon Heumos\,$^{\text{\sfb 2} \dagger}$,
Sven Nahnsen\,$^{\text{\sfb 2}}$,
Pjotr Prins\,$^{\text{\sfb 3}}$,
and Erik Garrison\,$^{\text{\sfb 3}*}$
}

\address{
$^{\text{\sf 1}}$University of Tor Vergata, Rome, Italy \\
$^{\text{\sf 2}}$Quantitative Biology Center (QBiC), University of T\"ubingen, T\"ubingen, Germany, 72076 \\
$^{\text{\sf 3}}$University of Tennessee Health Science Center, Memphis, TN, USA
}

\corresp{$^\ast$To whom correspondence should be addressed. \\
$^\dagger$Contributed equally.}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: XXXXXXX}

% XXX key message of the paper is that we have collected a set of algorithms that enable easy use of pangenome graphs for investigating biology

\abstract{
\textbf{Motivation:} Pangenome graphs provide a complete representation of the mutual alignment of collections of genomes.
These models offer the opportunity to study the total genomic diversity of a population, including structurally complex regions.
Analyzing hundreds of gigabase-scale genomes using this model is difficult and not well-supported by existing tools.
%In addition, vertebrate genomes present highly repetitive regions which increase the complexity of the analysis.
Efficient and flexible tools are therefore required to work on pangenome graphs of any complexity and scale. \\
\textbf{Results:} Here we present ODGI, a new suite of tools to analyze and manipulate pangenome graphs structured in the variation graph model.
ODGI supports graphs in the Graphical Fragment Assembly format version 1 (GFAv1).
The tools scale efficiently to large collections of eukaryotic genomes, allowing users to work easily with pangenome graphs of tens to thousands of large genomes while maintaining fast execution runtime and low memory overhead.
\textbf{Availability:} ODGI is written in C++. Its source code is freely available at \url{https://github.com/pangenome/odgi} with documentation at \url{https://odgi.readthedocs.io}.
ODGI can be installed via Bioconda \url{https://bioconda.github.io/recipes/odgi/README.html} or Guix https://github.com/ekg/guix-genomics/blob/master/odgi.scm. \\
\textbf{Contact:} \href{egarris5@uthsc.edu}{egarris5@uthsc.edu} \\
\textbf{Supplementary information:} Supplementary data are available at \textit{Bioinformatics} online.
}

\maketitle

\section{Introduction}

A pangenome models the full set of genomic elements in a given species or clade {32453966}. Indeed, these data structures encode the mutual relationships between all the genomes represented, in contrast to reference-based approaches which relate sequences only to a particular genome, chosen as reference. A class of methods to represent pangenomes involves the sequence graphs {2488477}, where similar orthologous regions between genomes collapse into a single representative sequence. In node-labeled sequence graphs, nodes indicate DNA sequences, with edges connecting the nodes that are concatenated in the sequences represented in the graph. A bidirected sequence graph represents both strands of DNA. On this model, variation graphs add the concept of path to embed linear sequences (e.g., genomes or haplotypes) into the graph {30125266}. Paths provide a stable coordinate system, allowing graph annotations and interoperability between different graphs.

Thanks to advances in sequencing technologies, new genome assemblies are produced at a high rate. This amount of data offers the opportunity to study genomic variation as never before, but it also brings challenges in how to represent and manipulate hundreds of genomes at a gigabase scale. Variation graphs compactly represent the full genetic variation across a population, but graph-based data structures present computational overheads: in addition to the sequences, they must also represent the graph topology. Several genome data structures were developed to address these challenges {33040146}. Memory-efficient representations do not allow dynamic updates to the graph, such as adding new genomes or simplifying the graph topology. Furthermore, dynamic updates must perform efficiently on the complex graphs generated from whole-genome alignment of vertebrates. Highly repetitive regions, such as centromeres, segmental duplications, and acrocentric chromosomes lead to graphs that present paths with very high-depth nodes. The node depth is defined as the number of times in which the node is crossed by all the paths embedded in the graph. High depth increases the complexity of the operations performed on the paths and the nodes they cross.

To overcome this limitation, we have developed an Optimized Dynamic Genome/Graph Implementation (ODGI). Each tool loads graphs into the succinct dynamic HandleGraph model {33040146} and applies methods based on the HandleGraph API. Several algorithms are shared with the VG toolkit (VG) {30125266}, the state-of-the-art toolkit for working with pangenome graphs. However, although similar in scope to VG, ODGI importantly differs in its design to support highly complex pangenome graphs. The majority of the ODGI tools are implemented in an index-free manner, avoiding the burning task needed to create an index structure. Indeed, index-constrained implementations would require building indexes also for single or little operations on the graphs. Moreover, thanks to its efficient path representation, ODGI tools can build and walk the internal graph representation (the ODGI format) in parallel, which is one of the major bottlenecks when working with very large and deep variation graphs, efficiently scaling up to hundreds of large vertebrate genomes.

\cite{Eizenga_2020}

%\begin{methods}

\section{Implementation}

ODGI is designed to build and modify paths in parallel, keeping its representation in memory efficient.
It applies concepts first introduced in the dynamic version of the Graph BWT {31406990} (gBWT), a scalable implementation of the graph extension of the positional Burrows-Wheeler transform {28702075}.
Specifically, we build a node-local model of the graph, where the graph is stored in a vector of node structures.
The identifier of each node is its offset in this vector plus 1.
Each structure contains the sequence of the node, its edges in both directions (forward and backward), and a vector of path steps that describes how the embedded paths walk across the node.
Each step records the path identifier and the previous and next path steps on the same path.
To reduce the encoding, we encode path steps using a local alphabet that maps the N neighbors of the node into the range $1\ldots N$.
To further save space, node deltas, rather than IDs, are stored in this alphabet.
The delta between two nodes is defined as their distance in the graph vector (i.e., the difference between the node offsets).
The path step vector, of length n, is stored using a dynamic succinct integer vector that requires O(5nw) bits, where w is ~log2(N).
Finally, to allow operating on path steps in parallel, each node structure includes a byte-width mutex lock.

%\end{methods}

ODGI is entirely focused on “first-order” operations on the graph (Table 1), providing, unlike VG, no method to construct graphs from raw sequences or map reads.
It supports interrogation of the graph for basic dimensional properties, positional and path-related queries, and visualization in one-dimension (1D) and two-dimensions (2D).
ODGI also supports operations on the graph such as subset, subdivide, break, combine, normalize, or order its components, nodes, and paths.
Most of the tools are designed to be applied together, piping the output of one tool into the next, thereby preventing the creation of intermediate files, and reducing the number of IO operations.

%\subsection{Core functionality}

Variation graphs are commonly represented by a subset of version 1 of the Graphical Fragment Assembly format (GFAv1): odgi build and odgi view allow to convert graphs from GFA to ODGI format and vice versa, respectively.
In the variation graph model, paths have to respect the graph’s topology: this can be verified with odgi validate, to ensure no errors in the input or edited graphs.

By visualizing pangenome graphs, we can gain insight into the relationship between genomes.
odgi viz applies binning and direct rendering to a raster image to generate a 1D representation able to scale up to gigabase pangenome graphs (Figure 1.A).
However, pangenome graphs may present complex structures to visualize: odgi sort finds the best node order to simplify 1D graph visualization by applying several cutting-edge sorting algorithms.
odgi draw extends the visualization in 2D, taking in input the layouts built by odgi layout.

Applying odgi stats, users can retrieve metrics describing the graph properties, such as the number of nodes, edges, paths, and graph length.
ODGI also offers more advanced tools for interrogating the graphs. odgi bin summarizes the path information into bins of specified size, enabling a summarized view of gigabase scale graphs.
odgi depth returns the node depth as defined by query criteria, allowing users to detect the complex regions in the graph due to sequences with highly identical repeats.
Complex motifs can be also detected with odgi degree, which returns the node degree as defined by query criteria.
High degree nodes are the mirror of misassemblies or problems in the pangenome building, making the tool useful for debugging the process as well.

ODGI allows edit operations on the graphs.
Cycles in the graph complicate downstream analyses: odgi break removes the cycles, reducing the complexity of the graph topology.
odgi groom removes spurious inverting links by exploring the graph from the orientation supported by most paths.
To enable efficient sequence alignment against the graph, long nodes can be divided into shorter nodes at a maximum requested size using odgi chop.
Partial order alignment, which consists of aligning sequences against a directed acyclic graph (DAG), is frequently used in pangenome building pipelines, but the current implementations return DAGs with 1-bp long nodes; odgi unchop allows joining nodes that can be merged without changing the graph topology, nor the embedded sequences, obtaining an equivalent, but more compact, representation of the graph.

Pangenome graphs can embed multiple chromosomes as separated connected components (inter-chromosomal structural variants would join the components into bigger ones).
odgi explode separates the connected components in different ODGI format files, while odgi squeeze allows merging multiple graphs into the same ODGI format file, preventing node ID collisions.
odgi extract allows extracting specific subregions of the graph as defined by query criteria, thereby simplifying the downstream analyses and reducing the resources to work only with the extracted region.

In variation graphs the coordinates are provided by the embedded path sequences.
Indeed, the node IDs are not meant to be stable. odgi position finds, translates, and liftovers graph and path positions between different graphs by exploiting their shared path sequences (Figure 1.B).

\begin{comment}
key message of the paper is that we have collected a set of algorithms that enable easy use of pangenome graphs for investigating biology
-> build model solves problem of working with big graphs in memory
-> view (convert to GFA) & paths solve problem of exporting basic features of the graph (e.g. paths)
-> stats (understand basic size / structure) & bin & degree & depth solves problem of understanding the overall structure and size of the graph
-> sort (groom) & layout solves problem of finding latent structure in the pangenome
-> viz & draw provides a human-viewable readout of the graph
-> chop & unchop & squeeze & break & prune & explode lets us break apart or combine the graph nodes and topology
-> position & tips & untangle (jaccard based coordinate conversion) provides a way to map coordinates between any genomes in the graph (e.g. liftover!)
-> extract lets us pull out specific regions of the graph based on path ranges, nodes and positions
\end{comment}

\section{Results}

\subsection{Building the \textsc{ODGI} model}

% erik

% build
Solves problem of working with big and complex graphs in limited memory.

Figure: encoding model as a cartoon --  HTT exon 1 as tiny example graph (maybe)

\subsection{Converting to standard text formats}

% pjotr & andrea

% view / paths
Allows us to export basic data of the graph (genomes and graph structure).

Figure: .dot showing the relationship between all the tools and the data formats we use.

\subsection{Obtaining metrics of the pangenome graph}

% simon
% chr8 longs

% stats / bin / degree / depth / multiQC
Solves the problem of understanding the overall structure, size, and features of the graph and its sequences.

Figure: small graph with all the stats shown. HTT exon 1 as tiny example graph

\subsection{Finding latent structure in the pangenome graph topology}

% simon

% sort / layout / tension??
Allows us to understand the sparse structures typically found in pangenome graphs.

\subsection{Visualizing pangenome graphs}

% andrea (viz) & erik (draw)

% viz / draw
These provide scalable ways of geneating human-viewable pictures of the high-level structure of the graph.
% interesting that we don't go base-level at all... we use vg for that

Figure here with 1D + 2D vizs.

\subsection{Editing the graph structure}

% andrea (?)

% chop / unchop / squeeze / break / prune / explode
These are commonly-needed basic operations on the topology of the graph.

\subsection{Untangling and navigating the pangenome with path-based coordinates}

% erik

% position / tips
% untangle (this follows on the jaccard graph mapping concepts in the previous section}
The graph is a model of an alignment of many genomes.
We can use coordinates in any genome to refer to it, but this requires a few basic operations ...
Obtaining unambiguous mappings between different genomes requires the use of a new kind of graph based mapping (path graph jaccard).

Figure showing the untangling of C4 ?
Figure showing tips over a single human chromosome from HPRC.

\subsection{Extracting regions of interest}

% andrea (?)

% extract
Pangenome graphs are very large, but we often only want to work with a small portion (e.g. a single gene).
We can extract such regions using coordinates on the paths in the graph to guide us.

Figure showing extraction process---either schematic or ``real''.

\section{Discussion}

% erik & pjotr & anyone


\section*{Funding}

%This work was supported, in part, by the National Institutes of Health (award numbers U01HG010961, U41HG010972, R01HG010485, 2U41HG007234, 5U54HG007990, 5T32HG008345-04, U01HL137183 to B.P.) and the W. M. Keck Foundation (award number DT06172015 to B.P.).
S.H. acknowledges funding from the Central Innovation Programme (ZIM) for SMEs of the Federal Ministry for Economic Affairs and Energy of Germany.

\section*{Data availability}

Data used to build Human pangenome graphs is available at \url{https://github.com/human-pangenomics/HPP_Year1_Data_Freeze_v1.0}.

\bibliographystyle{natbib}
%\bibliographystyle{achemnat}
%\bibliographystyle{plainnat}
%\bibliographystyle{abbrv}
%\bibliographystyle{bioinformatics}
%
%\bibliographystyle{plain}
%
\bibliography{document}


% \begin{thebibliography}{}

% \bibitem[Bofelli {\it et~al}., 2000]{Boffelli03}
% Bofelli,F., Name2, Name3 (2003) Article title, {\it Journal Name}, {\bf 199}, 133-154.

% \bibitem[Bag {\it et~al}., 2001]{Bag01}
% Bag,M., Name2, Name3 (2001) Article title, {\it Journal Name}, {\bf 99}, 33-54.

% \bibitem[Yoo \textit{et~al}., 2003]{Yoo03}
% Yoo,M.S. \textit{et~al}. (2003) Oxidative stress regulated genes
% in nigral dopaminergic neurnol cell: correlation with the known
% pathology in Parkinson's disease. \textit{Brain Res. Mol. Brain
% Res.}, \textbf{110}(Suppl. 1), 76--84.

% \bibitem[Lehmann, 1986]{Leh86}
% Lehmann,E.L. (1986) Chapter title. \textit{Book Title}. Vol.~1, 2nd edn. Springer-Verlag, New York.

% \bibitem[Crenshaw and Jones, 2003]{Cre03}
% Crenshaw, B.,III, and Jones, W.B.,Jr (2003) The future of clinical
% cancer management: one tumor, one chip. \textit{Bioinformatics},
% doi:10.1093/bioinformatics/btn000.

% \bibitem[Auhtor \textit{et~al}. (2000)]{Aut00}
% Auhtor,A.B. \textit{et~al}. (2000) Chapter title. In Smith, A.C.
% (ed.), \textit{Book Title}, 2nd edn. Publisher, Location, Vol. 1, pp.
% ???--???.

% \bibitem[Bardet, 1920]{Bar20}
% Bardet, G. (1920) Sur un syndrome d'obesite infantile avec
% polydactylie et retinite pigmentaire (contribution a l'etude des
% formes cliniques de l'obesite hypophysaire). PhD Thesis, name of
% institution, Paris, France.

% \end{thebibliography}
\end{document}
